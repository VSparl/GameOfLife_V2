exec("\"\"\"Python terminal implementation of John Conway\'s Game of Life.\"\"\"\nimport sys\nimport os\nimport random\nfrom time import sleep\n\ntry:\n    # msvcrt is Windows-only\n    import msvcrt\n    # colorama needs to be installed separately\n    from colorama import Back, Fore\nexcept ImportError:\n    print(\"Error importing modules. Please run setup.py from a windows environment.\"\n          \"Also chceck if your Python version supports the msvcrt module.\\n\")\n    sys.exit(1)\n\n\nclass FileInvalidError(Exception):\n    \"\"\"Custom error for .gol files that don\'t pass the validity check.\"\"\"\n    def __init__(\n        self,\n        message=\"File didn\'t pass the validity check. \"\n        \"All characters must be printable and all lines must have the same length.\"):\n        self.message = message\n        super().__init__(self.message)\n\n\ndef set_dir_and_os():\n    \"\"\"Set the starting directory and check that the program is run on Windows.\n\n    Latter is due to the fact that the program can only run on windows.\n    \"\"\"\n    # Set working directory to the program directory\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n    if os.name != \"nt\":\n        print(f\"{Fore.RED}ERROR:{Fore.RESET} You don\'t seem to be running a Windows device.\\n\"\n              \"This game is only supported on the Windows operating system. Please use a VM \"\n              \"or a Windows device to run this game.\")\n        sys.exit(2)\n\n\ndef check_origin(filename: str) -> str:\n    \"\"\"Check boards and favourites folder and return the location of the file.\"\"\"\n    return BOARDS_PATH if filename in os.listdir(BOARDS_PATH) \\\n    else FAVOURITES_PATH if filename in os.listdir(FAVOURITES_PATH) \\\n    else None\n\n\ndef handle_special_args() -> str:\n    \"\"\"Handle special args that start with a hyphen (-)\n\n    Return the background character for the board or exit the program directly.\n\n    Other arguments will only be taken into account if the\n    first argument is valid.\n    A list of special arguments is found below:\n\n    -h to show a help message explaining the args and usage\n    -l to list the saved boards using the board creator (standalone program or module).\n    -e to erase all the files in the boards folder.\n    -f to mark the board specified in the next argument as a favourite.\n        Favourites are not affected by the -c argument.\n        If the file is already in the favourites folder, offer to move it back.\n    -n to create a new file with the specified name, even if a file with that name\n        already exists.\n    -d to delete the file, even if it is in the favourites folder.\n    -c to select the character used for the board background.\n        The -c arg is placed after the filename of a .gol board, if specified.\n    -t to select the time to sleep inbetween printing boards. Default is 0.25 s.\n    \"\"\"\n    if len(sys.argv) == 1:\n        # No args to handle\n        return \" \", 0.25\n    arg1 = sys.argv[1]\n    finish = False\n    board_filler, timeout = \" \", 0.25\n\n    if arg1 == \"-h\":  # Help\n        print(\"\"\"\nUsage: py main.py [args]\n\nThe first argument is either ONLY a filename (with or without extension)\nof a .gol board, or a special argument.\nA second argument will only be taken into account if paired with a valid special argument.\n\nSpecial args can be the following:\n-h to show this help message.\n-l to list the saved boards using the board creator (standalone program or module).\n-e to erase your boards folder.\n-f to mark the board specified in the next argument as a favourite.\n    Favourites are not affected by the -c argument.\n    Also use this argument to move back a board from the favourites folder.\n-n to create a new file with the specified name, even if a file with that name\n    already exists.\n-d to delete the file, even if it is in your favourites folder.\n-c to select the character that fills the board as background.\n    The -c argument is to be placed AFTER the name of a .gol board, if specified\n-t to select the amount of seconds between two generations. Default is 0.25 seconds.\n    Keep in mind that the actual\n    speed of generations still depends on the performance of your computer, especially\n    for big boards.\"\"\")\n        sys.exit(0)\n\n    if arg1 == \"-l\":  # List\n        print(f\"Saved boards:\\n{Fore.LIGHTBLUE_EX}\")\n        boards: list[str] = os.listdir(BOARDS_PATH)\n        boards.sort()\n        print(\"\\n\".join(boards))\n        # Show absolute path of boards folder for easy access\n        print(f\"{Fore.RESET}\\n{Fore.LIGHTBLACK_EX}\"\n              f\"Your boards are saved here: {BOARDS_PATH}\"\n              f\"{Fore.RESET}\\n\\n\")\n\n        print(f\"Favourites:\\n{Fore.LIGHTCYAN_EX}\")\n        boards: list[str] = os.listdir(FAVOURITES_PATH)\n        boards.sort()\n        print(\"\\n\".join(boards))\n        # Show absolute path of boards folder for easy access\n        print(f\"{Fore.RESET}\\n{Fore.LIGHTBLACK_EX}\"\n              f\"Your favourites are saved here: {FAVOURITES_PATH}\"\n              f\"{Fore.RESET}\")\n\n        sys.exit(0)\n\n    if arg1 == \"-e\":  # Erase\n        if input(\"Are you sure you want to DELETE all of your saved boards?\\n\"\n                 \"Favourites will not be affected. [y/n] \").lower() == \"y\":\n            for file in os.listdir(BOARDS_PATH):\n                # Remove each file but leave the folder\n                os.remove(os.path.join(BOARDS_PATH, file))\n\n            print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}Files deleted.\")\n        sys.exit(0)\n\n    if arg1 == \"-f\" and len(sys.argv) > 2:  # Favourite\n        fav_file = f\"{sys.argv[2]}{\'.gol\' if sys.argv[2][-4:] != \'.gol\' else \'\'}\"\n\n        if check_origin(fav_file) == BOARDS_PATH:\n            # File is there, ready to move to favourites\n            if input(\"Are you sure you want to move\"\n                     f\" \\\"{fav_file}\\\" to favourites? [y/n] \").lower() == \"y\":\n                os.makedirs(FAVOURITES_PATH, exist_ok=True)  # Create favourites directory\n                # Move file, keeping the name\n                os.rename(\n                    os.path.join(BOARDS_PATH, fav_file),\n                    os.path.join(FAVOURITES_PATH, fav_file))\n\n                print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}File moved successfully.\")\n                sys.exit(0)\n\n        if check_origin(fav_file) == FAVOURITES_PATH:\n            # File is already in favourites\n            if input(f\"\\\"{fav_file}\\\" is already in your favourites folder.\"\n                     \" Do you want to move it back to the other boards? [y/n] \").lower() == \"y\":\n                os.makedirs(BOARDS_PATH, exist_ok=True)  # User might have deleted boards directory\n                # Move file, keeping the name\n                os.rename(\n                    os.path.join(FAVOURITES_PATH, fav_file),\n                    os.path.join(BOARDS_PATH, fav_file))\n\n                print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}File moved successfully.\")\n                sys.exit(0)\n\n            else:\n                print(\"\\nNo files were moved.\")\n                sys.exit(0)\n\n        print(f\"{Fore.RED}ERROR: {Fore.RESET}File \\\"{fav_file}\\\" \"\n                \"could not be found. No files were moved.\")\n\n        sys.exit(1)\n\n    if arg1 == \"-n\" and len(sys.argv) > 2:  # New file\n        # Set the name of the file to override\n        file_to_override: str = add_extension(sys.argv[2])\n        if input(f\"\"\"If the file doesn\'t exist yet, a new one will be created.\nAre you sure you want to override the file \\\"{file_to_override}\\\"? [y/n] \"\"\").lower() == \"y\":\n            print()\n            manually_create_level(file_to_override)\n        sys.exit(0)\n\n    if arg1 == \"-d\" and len(sys.argv) > 2:  # Delete\n        # Set the name of the file to delete\n        file_to_delete = f\"{sys.argv[2]}{\'.gol\' if sys.argv[2][-4:] != \'.gol\' else \'\'}\"\n        try:\n            os.remove(os.path.join(check_origin(file_to_delete), file_to_delete))\n            print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}File deleted successfully.\")\n        except TypeError:\n            # Because of the None return in check_origin\n            print(f\"{Fore.RED}ERROR: {Fore.RESET}The filename \\\"{file_to_delete}\\\" \"\n                  \"doesn\'t seem to exist, so nothing was deleted.\")\n        sys.exit(0)\n\n    if len(sys.argv) > 2 and any(arg == \"-c\" for arg in sys.argv):  # Char\n        # Assign to the char after arg\n        board_filler = sys.argv[sys.argv.index(\"-c\") + 1]\n\n        finish = True\n\n        while len(board_filler) != 1:\n            board_filler = input(\"Exactly ONE character can fill the board. Enter new character: \")\n\n    if len(sys.argv) > 2 and any(arg == \"-t\" for arg in sys.argv):  # Time\n        timeout = sys.argv[sys.argv.index(\"-t\") + 1]\n        while not timeout.replace(\".\", \"\", 1).isdigit():\n            timeout = input(\"Enter a float or int as a board timeout: \")\n\n        timeout = float(timeout)\n        finish = True\n\n    if sys.argv[1][0] == \"-\" and not finish:  # Invalid\n        print(f\"{Fore.RED}ERROR: {Fore.RESET}\"\n              \"Invalid argument. Filenames cannot start with a hyphen. See -h for help.\")\n        sys.exit(1)\n\n    return board_filler, timeout  # Default filler, default interval\n\n\ndef display_welcome() -> None:\n    \"\"\"Print some welcome words and infos regarding the game.\n    \n    Credit to https://fsymbols.com/generators/carty/ for the ASCII art.\n    \"\"\"\n    os.system(\"cls\")\n    print(\"\"\"\n░░░░░██╗░█████╗░██╗░░██╗███╗░░██╗  ░█████╗░░█████╗░███╗░░██╗░██╗░░░░░░░██╗░█████╗░██╗░░░██╗██╗░██████╗\n░░░░░██║██╔══██╗██║░░██║████╗░██║  ██╔══██╗██╔══██╗████╗░██║░██║░░██╗░░██║██╔══██╗╚██╗░██╔╝╚█║██╔════╝\n░░░░░██║██║░░██║███████║██╔██╗██║  ██║░░╚═╝██║░░██║██╔██╗██║░╚██╗████╗██╔╝███████║░╚████╔╝░░╚╝╚█████╗░\n██╗░░██║██║░░██║██╔══██║██║╚████║  ██║░░██╗██║░░██║██║╚████║░░████╔═████║░██╔══██║░░╚██╔╝░░░░░░╚═══██╗\n╚█████╔╝╚█████╔╝██║░░██║██║░╚███║  ╚█████╔╝╚█████╔╝██║░╚███║░░╚██╔╝░╚██╔╝░██║░░██║░░░██║░░░░░░██████╔╝\n░╚════╝░░╚════╝░╚═╝░░╚═╝╚═╝░░╚══╝  ░╚════╝░░╚════╝░╚═╝░░╚══╝░░░╚═╝░░░╚═╝░░╚═╝░░╚═╝░░░╚═╝░░░░░░╚═════╝░\n\n░██████╗░░█████╗░███╗░░░███╗███████╗  ░█████╗░███████╗  ██╗░░░░░██╗███████╗███████╗\n██╔════╝░██╔══██╗████╗░████║██╔════╝  ██╔══██╗██╔════╝  ██║░░░░░██║██╔════╝██╔════╝\n██║░░██╗░███████║██╔████╔██║█████╗░░  ██║░░██║█████╗░░  ██║░░░░░██║█████╗░░█████╗░░\n██║░░╚██╗██╔══██║██║╚██╔╝██║██╔══╝░░  ██║░░██║██╔══╝░░  ██║░░░░░██║██╔══╝░░██╔══╝░░\n╚██████╔╝██║░░██║██║░╚═╝░██║███████╗  ╚█████╔╝██║░░░░░  ███████╗██║██║░░░░░███████╗\n░╚═════╝░╚═╝░░╚═╝╚═╝░░░░░╚═╝╚══════╝  ░╚════╝░╚═╝░░░░░  ╚══════╝╚═╝╚═╝░░░░░╚══════╝\n\"\"\")\n    if input(\"Woud you like to display the instructions? [y/n] \").lower() != \"y\":\n        os.system(\"cls\")\n        return\n\n    print()\n    print(f\"\"\"\n{Back.LIGHTWHITE_EX}{Fore.BLACK}Overviev:{Back.RESET}{Fore.RESET}\nThe Game of Life is a cellular automaton devised by mathematician John Conway in 1970.\nIt\'s a zero-player game, meaning its evolution is determined by its initial state, with no further input.\nThe game is played on a grid of cells, each of which can be in one of two states: alive or dead.\nEach generation is created by applying the game rules simultaneously to every cell on the board,\nso that births and deaths occur simultaneously.\n\n{Back.LIGHTWHITE_EX}{Fore.BLACK}Rules:{Back.RESET}{Fore.RESET}\nBirths:    A dead cell with exactly three live neighbors becomes alive in the next generation.\nSurvivals: A live cell with two or three live neighbors survives to the next generation.\nDeaths:    A live cell with fewer than two live neighbors dies due to underpopulation,\n                and a live cell with more than three live neighbors dies due to overpopulation.\n\n{Back.LIGHTWHITE_EX}{Fore.BLACK}Additional information:{Back.RESET}{Fore.RESET}\nAlso read the README.md file for more information or launch the game with the \"-h\" command line argument.\nThis game looks and works best in the new windows terminal application\n    (the default terminal app for Windows 11)\nTry to pinch to zoom out for more cells in the simulation when using an auto-generated board.\n\"\"\")\n    input(\"Press [Enter] to continue to the game.\")\n    os.system(\"cls\")\n\n\ndef get_start_board() -> list[list[bool]]:\n    \"\"\"Handle and return a board based on the command line arguments.\"\"\"\n    # Get filename to import from command line args, avoiding special args\n    filename: str = sys.argv[1] if len(sys.argv) > 1 and \"-\" not in sys.argv[1] else \"\"\n\n    if filename:\n        try:\n            # Try to import the file from the specified filepath\n            local_board = import_from_file(filename)\n\n        except TypeError:\n            # File doesn\'t exist\n            if input(f\"{Fore.RED}ERROR:{Fore.RESET} Your file was not found.\\n\"\n                     \"Do you want to start the level editor to make your own board? [y/n] \"\n                     ).lower() == \"y\":\n                # Prompt user to create their own board with the filename\n                local_board = manually_create_level(filename)\n\n            else: sys.exit(0)\n\n        except FileInvalidError:\n            print(f\"{Fore.RED}ERROR: {Fore.RESET}File invalid. Try again with another file.\")\n            if input(\"Would you like to delete the file? [y/n] \").lower() == \"y\":\n                # Delete invalid file\n                filename = add_extension(filename)\n                # Look in both the boards and the favourites folder\n                os.remove(os.path.join(check_origin(filename), filename))\n                print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}{filename} deleted successfully\")\n\n            sys.exit(1)\n\n    else:\n        # No args, full terminal boards will be created\n        local_board = generate_random_board()\n\n    return local_board\n\n\ndef controlled_input(input_string: str, max_len: int) -> list[str]:\n    \"\"\"Input function but with max length\n\n    Automatically returns and goes on to the next line when the specified\n    input length has been reached.\n    Still allows for Ctrl+C to interrupt the program.\n    This function was written with the help of ChatGPT.\n\n    WARNING: This only works on Windows devices.\n    \"\"\"\n    input_chars: list[str] = []\n    print(input_string, end=\"\", flush=True)\n\n    while True:\n        if msvcrt.kbhit():  # React to keyboard input\n            # Get typed character from keyboard and decode it\n            char = msvcrt.getwch()\n            # Handle all exceptions and special keys\n            if char == \"\\x03\":  # Ctrl+C\n                # Simulate same behaviour of \"regular\" Ctrl+C\n                raise KeyboardInterrupt\n\n            if char == \"\\x08\":  # Backspace key\n                if input_chars:\n                    input_chars.pop()\n                    # Move cursor back, overwrite character with a space\n                    print(\"\\b \\b\", end=\"\", flush=True)\n                continue\n\n            if char == \"\\r\":  # Enter key\n                # Function returns automatically\n                continue\n\n            # Add typed character to list and print it to the screen\n            input_chars.append(char)\n            print(char, end=\"\", flush=True)\n\n            if len(input_chars) >= max_len:\n                # Desired length reached\n                break\n\n    print()\n    return input_chars\n\n\ndef generate_random_board(height: int = -1, width: int = -1) -> list[list[bool]]:\n    \"\"\"Generates a random starting configuration of a board.\n\n    Arguments specify the size of the board.\n    A cell has a 50% chance to contain a counter.\n\n    If the args are -1 for both height and width, the numbers will be\n    selected so that the game consumes the entire screen.\n    \"\"\"\n    local_board: list[list[bool]] = []\n\n    if (height, width) == (-1, -1):\n        # Fill the entire screen\n        terminal = os.get_terminal_size()\n        # Terminal rendering doesn\'t like fullscreen, make place for generation count\n        height = terminal.lines - 3\n        # One cell is 2 chars wide, make place for separator\n        width = terminal.columns // 2 - 1\n\n    for _ in range(height):\n        # Generate a line of bools\n        generated_line = [(random.random() <= 0.5) for _ in range(width)]\n        local_board.append(generated_line)\n\n    return local_board\n\n\ndef import_from_file(filepath: str) -> list[list[bool]]:\n    \"\"\"Turns a file into a proper list and checks the validity of the board.\"\"\"\n    local_board: list[list[bool]] = []\n    line: str = \"PLACEHOLDER\"\n\n    # Add file extension if it wasn\'t provided\n    filepath = add_extension(filepath)\n\n    with open(os.path.join(check_origin(filepath), filepath), \"r\", encoding=\"utf-8\") as fp:\n        print(f\"{Fore.GREEN}SUCCESS: {Fore.RESET}File found, initializing...\")\n        sleep(1.2)\n\n        while line:\n            line = fp.readline().strip(\"\\n\")\n            # Convert char to bool value\n            processed_line = [not char == \" \" for char in line]\n            if processed_line:\n                # Avoids empty lists, they exist for some reason\n                local_board.append(processed_line)\n\n    if check_validity(local_board):\n        return local_board\n\n    # File is faulty\n    raise FileInvalidError\n\n\ndef check_validity(board: list[list[bool]]) -> bool:\n    \"\"\"Check if the formatting is valid in a starting configuration file.\n\n    Count the different lengths of rows on a board.\n    All rows should be the same length.\n    \"\"\"\n    last_col = -1\n    diff_cols = 0\n    for _, col in enumerate(board[:-1]):\n        curr_col = len(col)\n\n        if curr_col != last_col:\n            diff_cols += 1\n\n        last_col = curr_col\n\n    return diff_cols == 1\n\n\ndef add_extension(filename: str) -> str:\n    \"\"\"Add the .gol extension to a file if not present already.\"\"\"\n    return filename + (\".gol\" if filename[-4:] != \".gol\" else \"\")\n\n\ndef manually_create_level(filename: str=\"\") -> list[list[bool]]:\n    \"\"\"Create a level according to user specifications.\n\n    If no filename is specified, it will only return the board.\n    The new level will be saved in a .gol file as characters\n    if a filename is specified.\n\n    Print a success message at the end if all worked well.\n    \"\"\"\n    local_board: list[list[str]] = []\n    if filename:  # Do only if config should be saved in a file\n        filename = add_extension(filename)\n\n    with open(os.path.join(BOARDS_PATH, filename), \"w\", encoding=\"utf-8\") as fp:\n        if check_origin(filename) == FAVOURITES_PATH:\n            print(f\"A file called \\\"{filename}\\\" is already in your favourites.\")\n            filename = filename[:-4] + \"(1)\" + filename[-4:]  # Add ending (1) to filename\n            print(f\"A file called \\\"{filename}\\\" will be created instead.\")\n\n        print()\n        # Get parameters for the board from the user\n        while True:\n            width: str = input(\"Enter board width (cells): \")\n            if not width.isnumeric() or int(width) <= 1:\n                print(\"Minimum value is 2. Please only write numbers\\n\")\n                continue\n\n            height: str = input(\"Enter board height (cells): \")\n            if not height.isnumeric() or int(height) <= 1:\n                print(\"Minimum value is 2. Please only write numbers\\n\")\n                continue\n\n            height, width = int(height), int(width)\n            break\n\n        print()\n        # Actually get and save input\n        for i in range(height):\n            # Format and write chars entered by user\n            line: list[str] = controlled_input(f\"Enter line No. {i + 1}: \", width)\n            # Directly convert input to bool values\n            processed_input = [not char == \" \" for char in line]\n            local_board.append(processed_input)\n\n            if filename:\n                # Include in file if specified\n                fp.write(\"\".join(line))\n                if i != height - 1:\n                    # Don\'t write last newline\n                    fp.write(\"\\n\")\n\n        if filename: # Again, only if saved in file\n            print(f\"\\n{Fore.GREEN}SUCCESS: {Fore.RESET}File created successfully!\")\n\n    return local_board\n\n\ndef count_neighbors(board: list[list[bool]], row: int, col: int) -> int:\n    \"\"\"Count the number of live neighbors for a given cell.\n\n    Iterate over relative positions of neighbour cells\n    and check the state of the counters inside.\n    \"\"\"\n    # Relative position of the cells neighbours\n    neighbour_rel_pos: list = [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1),\n                               (row, col - 1),                     (row, col + 1),\n                               (row + 1, col - 1), (row + 1, col), (row + 1, col + 1),]\n\n    live_neighbors: int = 0\n    for i, j in neighbour_rel_pos:\n        #           counter is in a valid position          cell is alive\n        if (0 <= i < len(board) and 0 <= j < len(board[0])) and board[i][j]:\n            live_neighbors += 1\n\n    return live_neighbors\n\n\ndef update_board(board: list[list[bool]], count: int) -> list[list[bool]]:\n    \"\"\"Update the board according to the rules of the Game of Life.\n    \n    Credit to Mizipor on StackOverflow for the non-blocking input.\n    Link to the thread: https://stackoverflow.com/questions/2408560/non-blocking-console-input\n    \"\"\"\n    # Initialize a board where all cells are dead\n    new_board: list[list[bool]] = [[False] * len(board[0]) for _ in range(len(board))]\n    live_cells = 0  # To check if entire board is dead\n\n    for i, _ in enumerate(board):\n        for j, counter in enumerate(board[i]):\n            live_neighbors = count_neighbors(board, i, j)\n\n            # Apply Game of Life rules\n            #     live cell has 2 or 3 neighbours           cell is a birth cell -> 3 neighbours\n            if (counter and (live_neighbors in (2, 3))) or (not counter and live_neighbors == 3):\n                new_board[i][j] = True\n                live_cells += 1\n\n    if live_cells == 0:\n        # Entire board is dead, end the game with the amount of generations passed\n        end_game(count)\n\n    if msvcrt.kbhit():\n        if msvcrt.getch() == b\"\\r\":\n            # User has pressed [Enter] to exit the game mid-simulation.\n            end_game(count)\n\n\n    return new_board\n\n\ndef print_board(local_board: list[list[bool]], gen_count: int, character: str = \" \") -> None:\n    \"\"\"Print the current state of the board. Display the number of passed generations.\n\n    Colorama is used to draw colored characters.\n    Live cells are displayed as green.\n    The specified character is used to fill the cells, default is empty.\n\n    Screen flickering can occur, but that can\'t be avoided while not fundamentally\n    changing the structure of the program. This is due to how most terminal\n    applications handle output, which is line by line. When the ouput doesn\'t\n    happen to be synchronized with the monitor refresh rate, flickering can\'t be\n    avoided.\n    \"\"\"\n    # Initialize buffer to avoid screen flickering for bigger boards\n    buffered_board = \"\"\n\n    os.system(\"cls\")  # Clear the terminal\n\n    for row in local_board:\n        for cell in row:\n            # Color only if cell is alive\n            if cell:\n                buffered_board += f\"{Back.GREEN}{2 * character}{Back.RESET}\"\n            else:\n                buffered_board += 2 * character\n        buffered_board += \"|\\n\"  # Separator and newline after row\n    buffered_board += \"-\" * len(local_board[0]) * 2 + \"|\"  # Add bottom separator\n    buffered_board += f\"\\nGeneration No. {gen_count}\"\n\n    # Print only at the end to minimize flickering\n    print(buffered_board)\n\n\ndef end_game(count: int = -1) -> None:\n    \"\"\"Finish the game and display the number of passed generations.\"\"\"\n    print(\"\"\"\n░██████╗██╗███╗░░░███╗██╗░░░██╗██╗░░░░░░█████╗░████████╗██╗░█████╗░███╗░░██╗  ░█████╗░██╗░░░██╗███████╗██████╗░\n██╔════╝██║████╗░████║██║░░░██║██║░░░░░██╔══██╗╚══██╔══╝██║██╔══██╗████╗░██║  ██╔══██╗██║░░░██║██╔════╝██╔══██╗\n╚█████╗░██║██╔████╔██║██║░░░██║██║░░░░░███████║░░░██║░░░██║██║░░██║██╔██╗██║  ██║░░██║╚██╗░██╔╝█████╗░░██████╔╝\n░╚═══██╗██║██║╚██╔╝██║██║░░░██║██║░░░░░██╔══██║░░░██║░░░██║██║░░██║██║╚████║  ██║░░██║░╚████╔╝░██╔══╝░░██╔══██╗\n██████╔╝██║██║░╚═╝░██║╚██████╔╝███████╗██║░░██║░░░██║░░░██║╚█████╔╝██║░╚███║  ╚█████╔╝░░╚██╔╝░░███████╗██║░░██║\n╚═════╝░╚═╝╚═╝░░░░░╚═╝░╚═════╝░╚══════╝╚═╝░░╚═╝░░░╚═╝░░░╚═╝░╚════╝░╚═╝░░╚══╝  ░╚════╝░░░░╚═╝░░░╚══════╝╚═╝░░╚═╝\n\"\"\")\n    if count >= 0:\n        print(f\"Your game lasted {count} generation{\'s\' if count > 1 else \'\'}.\")\n    input(\"\\nPress [Enter] to exit the game.\")\n    os.system(\"cls\")\n    # Exit program with code 0\n    sys.exit(0)\n\n\n# Run the following even if module is imported\nset_dir_and_os()\n# Path to where the boards are stored\nBOARDS_PATH: str = os.path.abspath(os.path.join(\"..\", \"boards\"))\n# Favourite boards\nFAVOURITES_PATH: str = os.path.abspath(os.path.join(\"..\", \"favourites\"))\n\n# Make necessary directories if they don\'t exist already\nos.makedirs(BOARDS_PATH, exist_ok=True)\nos.makedirs(FAVOURITES_PATH, exist_ok=True)\n\n# Only run the following if program is called explicitly\nif __name__ == \"__main__\":\n    print(\"-\" * 20)  # Visual separator\n\n    BACKGROUND_CHAR, TIMEOUT = handle_special_args()  # Check special args first\n    display_welcome()  # Only if no special args were called\n\n    # Initial configuration comes either from the user or is randomly generated\n    current_board: list[list[bool]] = get_start_board()\n    # Avoid stuck screens that only include still lives\n    last_board: list[list[bool]] = []\n    num_generations: int = 0  # Keep track of how many generations passed\n\n    print(\"Starting simulation...\")\n    sleep(1.5)\n    # Main game loop\n    while last_board != current_board:\n        num_generations += 1\n        print_board(current_board, num_generations, BACKGROUND_CHAR)\n        last_board = current_board\n        current_board = update_board(current_board, num_generations)\n        sleep(TIMEOUT)\n\n    end_game(num_generations)\n")